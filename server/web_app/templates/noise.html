<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise</title>
    <link rel="stylesheet" href="/static/style.css?v=2025-01-01">
    <script src="/static/htmx.min.js?v=2025-01-01"></script>
</head>
<body>
    <main class="container">
        <nav class="topbar">
            <div class="brand">
                <strong>Noise</strong>
                <a class="button ghost" href="/">Daily</a>
                <a class="button ghost" href="/tools">Tools</a>
            </div>
            <div class="today">Person: {{ person }}</div>
        </nav>

        <article class="panel noise-panel">
            <div class="panel-header">
                <h3>Rain Noise</h3>
            </div>
            <p class="muted">Tap to start. It will loop endlessly until you stop it.</p>
            <div class="actions">
                <button class="button noise-toggle" type="button" id="noise-toggle" aria-pressed="false">
                    Play noise
                </button>
                <span class="noise-status muted" id="noise-status">Stopped</span>
            </div>
            <p class="muted noise-note">Keep this tab open while playing.</p>
        </article>
    </main>

    <script>
        const toggleButton = document.getElementById('noise-toggle');
        const statusLabel = document.getElementById('noise-status');
        let audioCtx = null;
        let noiseNodes = [];
        let masterGain = null;
        let lfo = null;
        let lfoGain = null;
        let driftTimer = null;
        let baseGain = 0.24;
        let isPlaying = false;

        function setStatus(playing) {
            isPlaying = playing;
            toggleButton.textContent = playing ? 'Stop noise' : 'Play noise';
            toggleButton.setAttribute('aria-pressed', playing ? 'true' : 'false');
            statusLabel.textContent = playing ? 'Playing' : 'Stopped';
        }

        function createNoiseBuffer() {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i += 1) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        function createRainLayer({ lowpassFreq, highpassFreq, gainValue, bassBoost }) {
            const source = audioCtx.createBufferSource();
            source.buffer = createNoiseBuffer();
            source.loop = true;

            const lowShelf = audioCtx.createBiquadFilter();
            lowShelf.type = 'lowshelf';
            lowShelf.frequency.value = 180;
            lowShelf.gain.value = bassBoost;

            const lowpass = audioCtx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = lowpassFreq;

            const highpass = audioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = highpassFreq;

            const gain = audioCtx.createGain();
            gain.gain.value = gainValue;

            source.connect(lowShelf);
            lowShelf.connect(lowpass);
            lowpass.connect(highpass);
            highpass.connect(gain);
            gain.connect(masterGain);

            return { source, nodes: [lowShelf, lowpass, highpass, gain] };
        }

        function createRainSound() {
            const layers = [];
            layers.push(createRainLayer({
                lowpassFreq: 900,
                highpassFreq: 50,
                gainValue: 0.3,
                bassBoost: 4,
            }));
            layers.push(createRainLayer({
                lowpassFreq: 6000,
                highpassFreq: 1200,
                gainValue: 0.08,
                bassBoost: 0,
            }));

            lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.07;
            lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0.025;
            lfo.connect(lfoGain);
            lfoGain.connect(masterGain.gain);
            lfo.start();

            return layers;
        }

        async function startNoise() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = baseGain;
                masterGain.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            noiseNodes = createRainSound();
            noiseNodes.forEach((layer) => layer.source.start());
            if (!driftTimer) {
                driftTimer = setInterval(() => {
                    const drift = (Math.random() - 0.5) * 0.04;
                    masterGain.gain.value = baseGain + drift;
                }, 2400);
            }
            setStatus(true);
        }

        function stopNoise() {
            noiseNodes.forEach((layer) => {
                layer.source.stop();
                layer.source.disconnect();
                layer.nodes.forEach((node) => node.disconnect());
            });
            noiseNodes = [];
            if (lfo) {
                lfo.stop();
                lfo.disconnect();
                lfo = null;
            }
            if (lfoGain) {
                lfoGain.disconnect();
                lfoGain = null;
            }
            if (driftTimer) {
                clearInterval(driftTimer);
                driftTimer = null;
            }
            setStatus(false);
        }

        if (!('AudioContext' in window || 'webkitAudioContext' in window)) {
            toggleButton.disabled = true;
            statusLabel.textContent = 'Unsupported browser';
        }

        toggleButton.addEventListener('click', async () => {
            if (isPlaying) {
                stopNoise();
                return;
            }
            try {
                await startNoise();
            } catch (err) {
                console.error(err);
                statusLabel.textContent = 'Unable to start audio';
            }
        });
    </script>
</body>
</html>
